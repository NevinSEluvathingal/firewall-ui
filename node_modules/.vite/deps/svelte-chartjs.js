import {
  BarController,
  BubbleController,
  Chart,
  DoughnutController,
  LineController,
  PieController,
  PolarAreaController,
  RadarController,
  ScatterController
} from "./chunk-3AVGR7RS.js";
import "./chunk-TDRWH72F.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  add_location,
  afterUpdate,
  assign,
  bind,
  binding_callbacks,
  bubble,
  create_component,
  current_component,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  get_spread_object,
  get_spread_update,
  init,
  insert_dev,
  listen,
  mount_component,
  noop,
  onDestroy,
  onMount,
  safe_not_equal,
  set_attributes,
  transition_in,
  transition_out,
  validate_slots
} from "./chunk-IS3EQ5Z3.js";
import "./chunk-XSLCAIPP.js";
import "./chunk-7U33LM2Z.js";

// node_modules/svelte-chartjs/dist/utils/svelte.js
var eventPrefix = /^on/;
var events = [];
Object.keys(globalThis).forEach((key) => {
  if (eventPrefix.test(key)) {
    events.push(key.replace(eventPrefix, ""));
  }
});
function useForwardEvents(getRef) {
  const component = current_component;
  const destructors = [];
  function forward(e) {
    bubble(component, e);
  }
  onMount(() => {
    const ref = getRef();
    events.forEach(ref instanceof Element ? (event) => destructors.push(listen(ref, event, forward)) : (event) => destructors.push(ref.$on(event, forward)));
  });
  onDestroy(() => {
    while (destructors.length) {
      destructors.pop()();
    }
  });
}

// node_modules/svelte-chartjs/dist/utils/events.js
function getDatasetAtEvent(chart, event) {
  return chart.getElementsAtEventForMode(event, "dataset", { intersect: true }, false);
}
function getElementAtEvent(chart, event) {
  return chart.getElementsAtEventForMode(event, "nearest", { intersect: true }, false);
}
function getElementsAtEvent(chart, event) {
  return chart.getElementsAtEventForMode(event, "index", { intersect: true }, false);
}

// node_modules/svelte-chartjs/dist/Chart.svelte
var file = "node_modules\\svelte-chartjs\\dist\\Chart.svelte";
function create_fragment(ctx) {
  let canvas;
  let canvas_levels = [
    /*props*/
    ctx[1]
  ];
  let canvas_data = {};
  for (let i = 0; i < canvas_levels.length; i += 1) {
    canvas_data = assign(canvas_data, canvas_levels[i]);
  }
  const block = {
    c: function create() {
      canvas = element("canvas");
      set_attributes(canvas, canvas_data);
      add_location(canvas, file, 40, 0, 895);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, canvas, anchor);
      ctx[8](canvas);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(canvas);
      }
      ctx[8](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function clean(props2) {
  let { data: data2, type: type2, options: options2, plugins: plugins2, children, $$scope, $$slots, ...rest } = props2;
  return rest;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Chart", slots, []);
  let { type } = $$props;
  let { data = { datasets: [] } } = $$props;
  let { options = {} } = $$props;
  let { plugins = [] } = $$props;
  let { updateMode = void 0 } = $$props;
  let { chart = null } = $$props;
  let canvasRef;
  let props = clean($$props);
  onMount(() => {
    $$invalidate(2, chart = new Chart(canvasRef, { type, data, options, plugins }));
  });
  afterUpdate(() => {
    if (!chart)
      return;
    $$invalidate(2, chart.data = data, chart);
    Object.assign(chart.options, options);
    chart.update(updateMode);
  });
  onDestroy(() => {
    if (chart)
      chart.destroy();
    $$invalidate(2, chart = null);
  });
  useForwardEvents(() => canvasRef);
  $$self.$$.on_mount.push(function() {
    if (type === void 0 && !("type" in $$props || $$self.$$.bound[$$self.$$.props["type"]])) {
      console.warn("<Chart> was created without expected prop 'type'");
    }
  });
  function canvas_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      canvasRef = $$value;
      $$invalidate(0, canvasRef);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("type" in $$new_props)
      $$invalidate(3, type = $$new_props.type);
    if ("data" in $$new_props)
      $$invalidate(4, data = $$new_props.data);
    if ("options" in $$new_props)
      $$invalidate(5, options = $$new_props.options);
    if ("plugins" in $$new_props)
      $$invalidate(6, plugins = $$new_props.plugins);
    if ("updateMode" in $$new_props)
      $$invalidate(7, updateMode = $$new_props.updateMode);
    if ("chart" in $$new_props)
      $$invalidate(2, chart = $$new_props.chart);
  };
  $$self.$capture_state = () => ({
    onMount,
    afterUpdate,
    onDestroy,
    ChartJS: Chart,
    useForwardEvents,
    clean,
    type,
    data,
    options,
    plugins,
    updateMode,
    chart,
    canvasRef,
    props
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("type" in $$props)
      $$invalidate(3, type = $$new_props.type);
    if ("data" in $$props)
      $$invalidate(4, data = $$new_props.data);
    if ("options" in $$props)
      $$invalidate(5, options = $$new_props.options);
    if ("plugins" in $$props)
      $$invalidate(6, plugins = $$new_props.plugins);
    if ("updateMode" in $$props)
      $$invalidate(7, updateMode = $$new_props.updateMode);
    if ("chart" in $$props)
      $$invalidate(2, chart = $$new_props.chart);
    if ("canvasRef" in $$props)
      $$invalidate(0, canvasRef = $$new_props.canvasRef);
    if ("props" in $$props)
      $$invalidate(1, props = $$new_props.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    canvasRef,
    props,
    chart,
    type,
    data,
    options,
    plugins,
    updateMode,
    canvas_binding
  ];
}
var Chart2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      type: 3,
      data: 4,
      options: 5,
      plugins: 6,
      updateMode: 7,
      chart: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Chart",
      options,
      id: create_fragment.name
    });
  }
  get type() {
    throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get plugins() {
    throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plugins(value) {
    throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateMode() {
    throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set updateMode(value) {
    throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Chart_default = Chart2;

// node_modules/svelte-chartjs/dist/Line.svelte
function create_fragment2(ctx) {
  let chart_1;
  let updating_chart;
  let current;
  const chart_1_spread_levels = [
    { type: "line" },
    /*props*/
    ctx[1]
  ];
  function chart_1_chart_binding(value) {
    ctx[4](value);
  }
  let chart_1_props = {};
  for (let i = 0; i < chart_1_spread_levels.length; i += 1) {
    chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    chart_1_props.chart = /*chart*/
    ctx[0];
  }
  chart_1 = new Chart_default({ props: chart_1_props, $$inline: true });
  ctx[3](chart_1);
  binding_callbacks.push(() => bind(chart_1, "chart", chart_1_chart_binding));
  const block = {
    c: function create() {
      create_component(chart_1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(chart_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const chart_1_changes = dirty & /*props*/
      2 ? get_spread_update(chart_1_spread_levels, [chart_1_spread_levels[0], get_spread_object(
        /*props*/
        ctx2[1]
      )]) : {};
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        chart_1_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      chart_1.$set(chart_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[3](null);
      destroy_component(chart_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Line", slots, []);
  Chart.register(LineController);
  let { chart = null } = $$props;
  let props;
  let baseChartRef;
  useForwardEvents(() => baseChartRef);
  function chart_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      baseChartRef = $$value;
      $$invalidate(2, baseChartRef);
    });
  }
  function chart_1_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("chart" in $$new_props)
      $$invalidate(0, chart = $$new_props.chart);
  };
  $$self.$capture_state = () => ({
    ChartJS: Chart,
    LineController,
    Chart: Chart_default,
    useForwardEvents,
    chart,
    props,
    baseChartRef
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("chart" in $$props)
      $$invalidate(0, chart = $$new_props.chart);
    if ("props" in $$props)
      $$invalidate(1, props = $$new_props.props);
    if ("baseChartRef" in $$props)
      $$invalidate(2, baseChartRef = $$new_props.baseChartRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, props = $$props);
  };
  $$props = exclude_internal_props($$props);
  return [chart, props, baseChartRef, chart_1_binding, chart_1_chart_binding];
}
var Line = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { chart: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Line",
      options,
      id: create_fragment2.name
    });
  }
  get chart() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Line_default = Line;

// node_modules/svelte-chartjs/dist/Radar.svelte
function create_fragment3(ctx) {
  let chart_1;
  let updating_chart;
  let current;
  const chart_1_spread_levels = [
    { type: "radar" },
    /*props*/
    ctx[1]
  ];
  function chart_1_chart_binding(value) {
    ctx[4](value);
  }
  let chart_1_props = {};
  for (let i = 0; i < chart_1_spread_levels.length; i += 1) {
    chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    chart_1_props.chart = /*chart*/
    ctx[0];
  }
  chart_1 = new Chart_default({ props: chart_1_props, $$inline: true });
  ctx[3](chart_1);
  binding_callbacks.push(() => bind(chart_1, "chart", chart_1_chart_binding));
  const block = {
    c: function create() {
      create_component(chart_1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(chart_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const chart_1_changes = dirty & /*props*/
      2 ? get_spread_update(chart_1_spread_levels, [chart_1_spread_levels[0], get_spread_object(
        /*props*/
        ctx2[1]
      )]) : {};
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        chart_1_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      chart_1.$set(chart_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[3](null);
      destroy_component(chart_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Radar", slots, []);
  Chart.register(RadarController);
  let { chart = null } = $$props;
  let props;
  let baseChartRef;
  useForwardEvents(() => baseChartRef);
  function chart_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      baseChartRef = $$value;
      $$invalidate(2, baseChartRef);
    });
  }
  function chart_1_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("chart" in $$new_props)
      $$invalidate(0, chart = $$new_props.chart);
  };
  $$self.$capture_state = () => ({
    ChartJS: Chart,
    RadarController,
    Chart: Chart_default,
    useForwardEvents,
    chart,
    props,
    baseChartRef
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("chart" in $$props)
      $$invalidate(0, chart = $$new_props.chart);
    if ("props" in $$props)
      $$invalidate(1, props = $$new_props.props);
    if ("baseChartRef" in $$props)
      $$invalidate(2, baseChartRef = $$new_props.baseChartRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, props = $$props);
  };
  $$props = exclude_internal_props($$props);
  return [chart, props, baseChartRef, chart_1_binding, chart_1_chart_binding];
}
var Radar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { chart: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Radar",
      options,
      id: create_fragment3.name
    });
  }
  get chart() {
    throw new Error("<Radar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<Radar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Radar_default = Radar;

// node_modules/svelte-chartjs/dist/Doughnut.svelte
function create_fragment4(ctx) {
  let chart_1;
  let updating_chart;
  let current;
  const chart_1_spread_levels = [
    { type: "doughnut" },
    /*props*/
    ctx[1]
  ];
  function chart_1_chart_binding(value) {
    ctx[4](value);
  }
  let chart_1_props = {};
  for (let i = 0; i < chart_1_spread_levels.length; i += 1) {
    chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    chart_1_props.chart = /*chart*/
    ctx[0];
  }
  chart_1 = new Chart_default({ props: chart_1_props, $$inline: true });
  ctx[3](chart_1);
  binding_callbacks.push(() => bind(chart_1, "chart", chart_1_chart_binding));
  const block = {
    c: function create() {
      create_component(chart_1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(chart_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const chart_1_changes = dirty & /*props*/
      2 ? get_spread_update(chart_1_spread_levels, [chart_1_spread_levels[0], get_spread_object(
        /*props*/
        ctx2[1]
      )]) : {};
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        chart_1_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      chart_1.$set(chart_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[3](null);
      destroy_component(chart_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Doughnut", slots, []);
  Chart.register(DoughnutController);
  let { chart = null } = $$props;
  let props;
  let baseChartRef;
  useForwardEvents(() => baseChartRef);
  function chart_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      baseChartRef = $$value;
      $$invalidate(2, baseChartRef);
    });
  }
  function chart_1_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("chart" in $$new_props)
      $$invalidate(0, chart = $$new_props.chart);
  };
  $$self.$capture_state = () => ({
    ChartJS: Chart,
    DoughnutController,
    Chart: Chart_default,
    useForwardEvents,
    chart,
    props,
    baseChartRef
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("chart" in $$props)
      $$invalidate(0, chart = $$new_props.chart);
    if ("props" in $$props)
      $$invalidate(1, props = $$new_props.props);
    if ("baseChartRef" in $$props)
      $$invalidate(2, baseChartRef = $$new_props.baseChartRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, props = $$props);
  };
  $$props = exclude_internal_props($$props);
  return [chart, props, baseChartRef, chart_1_binding, chart_1_chart_binding];
}
var Doughnut = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { chart: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Doughnut",
      options,
      id: create_fragment4.name
    });
  }
  get chart() {
    throw new Error("<Doughnut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<Doughnut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Doughnut_default = Doughnut;

// node_modules/svelte-chartjs/dist/Pie.svelte
function create_fragment5(ctx) {
  let chart_1;
  let updating_chart;
  let current;
  const chart_1_spread_levels = [
    { type: "pie" },
    /*props*/
    ctx[1]
  ];
  function chart_1_chart_binding(value) {
    ctx[4](value);
  }
  let chart_1_props = {};
  for (let i = 0; i < chart_1_spread_levels.length; i += 1) {
    chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    chart_1_props.chart = /*chart*/
    ctx[0];
  }
  chart_1 = new Chart_default({ props: chart_1_props, $$inline: true });
  ctx[3](chart_1);
  binding_callbacks.push(() => bind(chart_1, "chart", chart_1_chart_binding));
  const block = {
    c: function create() {
      create_component(chart_1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(chart_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const chart_1_changes = dirty & /*props*/
      2 ? get_spread_update(chart_1_spread_levels, [chart_1_spread_levels[0], get_spread_object(
        /*props*/
        ctx2[1]
      )]) : {};
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        chart_1_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      chart_1.$set(chart_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[3](null);
      destroy_component(chart_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pie", slots, []);
  Chart.register(PieController);
  let { chart = null } = $$props;
  let props;
  let baseChartRef;
  useForwardEvents(() => baseChartRef);
  function chart_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      baseChartRef = $$value;
      $$invalidate(2, baseChartRef);
    });
  }
  function chart_1_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("chart" in $$new_props)
      $$invalidate(0, chart = $$new_props.chart);
  };
  $$self.$capture_state = () => ({
    ChartJS: Chart,
    PieController,
    Chart: Chart_default,
    useForwardEvents,
    chart,
    props,
    baseChartRef
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("chart" in $$props)
      $$invalidate(0, chart = $$new_props.chart);
    if ("props" in $$props)
      $$invalidate(1, props = $$new_props.props);
    if ("baseChartRef" in $$props)
      $$invalidate(2, baseChartRef = $$new_props.baseChartRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, props = $$props);
  };
  $$props = exclude_internal_props($$props);
  return [chart, props, baseChartRef, chart_1_binding, chart_1_chart_binding];
}
var Pie = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { chart: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pie",
      options,
      id: create_fragment5.name
    });
  }
  get chart() {
    throw new Error("<Pie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<Pie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pie_default = Pie;

// node_modules/svelte-chartjs/dist/Bar.svelte
function create_fragment6(ctx) {
  let chart_1;
  let updating_chart;
  let current;
  const chart_1_spread_levels = [
    { type: "bar" },
    /*props*/
    ctx[1]
  ];
  function chart_1_chart_binding(value) {
    ctx[4](value);
  }
  let chart_1_props = {};
  for (let i = 0; i < chart_1_spread_levels.length; i += 1) {
    chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    chart_1_props.chart = /*chart*/
    ctx[0];
  }
  chart_1 = new Chart_default({ props: chart_1_props, $$inline: true });
  ctx[3](chart_1);
  binding_callbacks.push(() => bind(chart_1, "chart", chart_1_chart_binding));
  const block = {
    c: function create() {
      create_component(chart_1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(chart_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const chart_1_changes = dirty & /*props*/
      2 ? get_spread_update(chart_1_spread_levels, [chart_1_spread_levels[0], get_spread_object(
        /*props*/
        ctx2[1]
      )]) : {};
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        chart_1_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      chart_1.$set(chart_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[3](null);
      destroy_component(chart_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Bar", slots, []);
  Chart.register(BarController);
  let { chart = null } = $$props;
  let props;
  let baseChartRef;
  useForwardEvents(() => baseChartRef);
  function chart_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      baseChartRef = $$value;
      $$invalidate(2, baseChartRef);
    });
  }
  function chart_1_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("chart" in $$new_props)
      $$invalidate(0, chart = $$new_props.chart);
  };
  $$self.$capture_state = () => ({
    ChartJS: Chart,
    BarController,
    Chart: Chart_default,
    useForwardEvents,
    chart,
    props,
    baseChartRef
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("chart" in $$props)
      $$invalidate(0, chart = $$new_props.chart);
    if ("props" in $$props)
      $$invalidate(1, props = $$new_props.props);
    if ("baseChartRef" in $$props)
      $$invalidate(2, baseChartRef = $$new_props.baseChartRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, props = $$props);
  };
  $$props = exclude_internal_props($$props);
  return [chart, props, baseChartRef, chart_1_binding, chart_1_chart_binding];
}
var Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { chart: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Bar",
      options,
      id: create_fragment6.name
    });
  }
  get chart() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Bar_default = Bar;

// node_modules/svelte-chartjs/dist/PolarArea.svelte
function create_fragment7(ctx) {
  let chart_1;
  let updating_chart;
  let current;
  const chart_1_spread_levels = [
    { type: "polarArea" },
    /*props*/
    ctx[1]
  ];
  function chart_1_chart_binding(value) {
    ctx[4](value);
  }
  let chart_1_props = {};
  for (let i = 0; i < chart_1_spread_levels.length; i += 1) {
    chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    chart_1_props.chart = /*chart*/
    ctx[0];
  }
  chart_1 = new Chart_default({ props: chart_1_props, $$inline: true });
  ctx[3](chart_1);
  binding_callbacks.push(() => bind(chart_1, "chart", chart_1_chart_binding));
  const block = {
    c: function create() {
      create_component(chart_1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(chart_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const chart_1_changes = dirty & /*props*/
      2 ? get_spread_update(chart_1_spread_levels, [chart_1_spread_levels[0], get_spread_object(
        /*props*/
        ctx2[1]
      )]) : {};
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        chart_1_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      chart_1.$set(chart_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[3](null);
      destroy_component(chart_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PolarArea", slots, []);
  Chart.register(PolarAreaController);
  let { chart = null } = $$props;
  let props;
  let baseChartRef;
  useForwardEvents(() => baseChartRef);
  function chart_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      baseChartRef = $$value;
      $$invalidate(2, baseChartRef);
    });
  }
  function chart_1_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("chart" in $$new_props)
      $$invalidate(0, chart = $$new_props.chart);
  };
  $$self.$capture_state = () => ({
    ChartJS: Chart,
    PolarAreaController,
    Chart: Chart_default,
    useForwardEvents,
    chart,
    props,
    baseChartRef
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("chart" in $$props)
      $$invalidate(0, chart = $$new_props.chart);
    if ("props" in $$props)
      $$invalidate(1, props = $$new_props.props);
    if ("baseChartRef" in $$props)
      $$invalidate(2, baseChartRef = $$new_props.baseChartRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, props = $$props);
  };
  $$props = exclude_internal_props($$props);
  return [chart, props, baseChartRef, chart_1_binding, chart_1_chart_binding];
}
var PolarArea = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { chart: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PolarArea",
      options,
      id: create_fragment7.name
    });
  }
  get chart() {
    throw new Error("<PolarArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<PolarArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PolarArea_default = PolarArea;

// node_modules/svelte-chartjs/dist/Bubble.svelte
function create_fragment8(ctx) {
  let chart_1;
  let updating_chart;
  let current;
  const chart_1_spread_levels = [
    { type: "bubble" },
    /*props*/
    ctx[1]
  ];
  function chart_1_chart_binding(value) {
    ctx[4](value);
  }
  let chart_1_props = {};
  for (let i = 0; i < chart_1_spread_levels.length; i += 1) {
    chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    chart_1_props.chart = /*chart*/
    ctx[0];
  }
  chart_1 = new Chart_default({ props: chart_1_props, $$inline: true });
  ctx[3](chart_1);
  binding_callbacks.push(() => bind(chart_1, "chart", chart_1_chart_binding));
  const block = {
    c: function create() {
      create_component(chart_1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(chart_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const chart_1_changes = dirty & /*props*/
      2 ? get_spread_update(chart_1_spread_levels, [chart_1_spread_levels[0], get_spread_object(
        /*props*/
        ctx2[1]
      )]) : {};
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        chart_1_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      chart_1.$set(chart_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[3](null);
      destroy_component(chart_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Bubble", slots, []);
  Chart.register(BubbleController);
  let { chart = null } = $$props;
  let props;
  let baseChartRef;
  useForwardEvents(() => baseChartRef);
  function chart_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      baseChartRef = $$value;
      $$invalidate(2, baseChartRef);
    });
  }
  function chart_1_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("chart" in $$new_props)
      $$invalidate(0, chart = $$new_props.chart);
  };
  $$self.$capture_state = () => ({
    ChartJS: Chart,
    BubbleController,
    Chart: Chart_default,
    useForwardEvents,
    chart,
    props,
    baseChartRef
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("chart" in $$props)
      $$invalidate(0, chart = $$new_props.chart);
    if ("props" in $$props)
      $$invalidate(1, props = $$new_props.props);
    if ("baseChartRef" in $$props)
      $$invalidate(2, baseChartRef = $$new_props.baseChartRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, props = $$props);
  };
  $$props = exclude_internal_props($$props);
  return [chart, props, baseChartRef, chart_1_binding, chart_1_chart_binding];
}
var Bubble = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { chart: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Bubble",
      options,
      id: create_fragment8.name
    });
  }
  get chart() {
    throw new Error("<Bubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<Bubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Bubble_default = Bubble;

// node_modules/svelte-chartjs/dist/Scatter.svelte
function create_fragment9(ctx) {
  let chart_1;
  let updating_chart;
  let current;
  const chart_1_spread_levels = [
    { type: "scatter" },
    /*props*/
    ctx[1]
  ];
  function chart_1_chart_binding(value) {
    ctx[4](value);
  }
  let chart_1_props = {};
  for (let i = 0; i < chart_1_spread_levels.length; i += 1) {
    chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    chart_1_props.chart = /*chart*/
    ctx[0];
  }
  chart_1 = new Chart_default({ props: chart_1_props, $$inline: true });
  ctx[3](chart_1);
  binding_callbacks.push(() => bind(chart_1, "chart", chart_1_chart_binding));
  const block = {
    c: function create() {
      create_component(chart_1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(chart_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const chart_1_changes = dirty & /*props*/
      2 ? get_spread_update(chart_1_spread_levels, [chart_1_spread_levels[0], get_spread_object(
        /*props*/
        ctx2[1]
      )]) : {};
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        chart_1_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      chart_1.$set(chart_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chart_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chart_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[3](null);
      destroy_component(chart_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Scatter", slots, []);
  Chart.register(ScatterController);
  let { chart = null } = $$props;
  let props;
  let baseChartRef;
  useForwardEvents(() => baseChartRef);
  function chart_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      baseChartRef = $$value;
      $$invalidate(2, baseChartRef);
    });
  }
  function chart_1_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("chart" in $$new_props)
      $$invalidate(0, chart = $$new_props.chart);
  };
  $$self.$capture_state = () => ({
    ChartJS: Chart,
    ScatterController,
    Chart: Chart_default,
    useForwardEvents,
    chart,
    props,
    baseChartRef
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("chart" in $$props)
      $$invalidate(0, chart = $$new_props.chart);
    if ("props" in $$props)
      $$invalidate(1, props = $$new_props.props);
    if ("baseChartRef" in $$props)
      $$invalidate(2, baseChartRef = $$new_props.baseChartRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, props = $$props);
  };
  $$props = exclude_internal_props($$props);
  return [chart, props, baseChartRef, chart_1_binding, chart_1_chart_binding];
}
var Scatter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { chart: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Scatter",
      options,
      id: create_fragment9.name
    });
  }
  get chart() {
    throw new Error("<Scatter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<Scatter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Scatter_default = Scatter;

// node_modules/svelte-chartjs/dist/index.js
var Base = Chart_default;
var Polar = PolarArea_default;
export {
  Bar_default as Bar,
  Base,
  Bubble_default as Bubble,
  Chart_default as Chart,
  Doughnut_default as Doughnut,
  Line_default as Line,
  Pie_default as Pie,
  Polar,
  PolarArea_default as PolarArea,
  Radar_default as Radar,
  Scatter_default as Scatter,
  getDatasetAtEvent,
  getElementAtEvent,
  getElementsAtEvent,
  useForwardEvents
};
//# sourceMappingURL=svelte-chartjs.js.map
