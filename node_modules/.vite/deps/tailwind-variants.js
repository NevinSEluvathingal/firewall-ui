import {
  extendTailwindMerge,
  twMerge
} from "./chunk-MRTSRWFL.js";
import "./chunk-7U33LM2Z.js";

// node_modules/tailwind-variants/dist/chunk-JXBJZR5A.js
var l = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e;
var u = (e) => !e || typeof e != "object" || Object.keys(e).length === 0;
var x = (e, o) => JSON.stringify(e) === JSON.stringify(o);
function i(e, o) {
  e.forEach(function(r) {
    Array.isArray(r) ? i(r, o) : o.push(r);
  });
}
function y(e) {
  let o = [];
  return i(e, o), o;
}
var a = (...e) => y(e).filter(Boolean);
var p = (e, o) => {
  let r = {}, c = Object.keys(e), f = Object.keys(o);
  for (let t of c)
    if (f.includes(t)) {
      let s = e[t], n = o[t];
      typeof s == "object" && typeof n == "object" ? r[t] = p(s, n) : Array.isArray(s) || Array.isArray(n) ? r[t] = a(n, s) : r[t] = n + " " + s;
    } else
      r[t] = e[t];
  for (let t of f)
    c.includes(t) || (r[t] = o[t]);
  return r;
};
var g = (e) => !e || typeof e != "string" ? e : e.replace(/\s+/g, " ").trim();

// node_modules/tailwind-variants/dist/index.js
var ie = { twMerge: true, twMergeConfig: {}, responsiveVariants: false };
var Z = (s) => s || void 0;
var N = (...s) => Z(y(s).filter(Boolean).join(" "));
var R = null;
var C = {};
var q = false;
var j = (...s) => (b$1) => b$1.twMerge ? ((!R || q) && (q = false, R = u(C) ? twMerge : extendTailwindMerge({ ...C, extend: { theme: C.theme, classGroups: C.classGroups, conflictingClassGroupModifiers: C.conflictingClassGroupModifiers, conflictingClassGroups: C.conflictingClassGroups, ...C.extend } })), Z(R(N(s)))) : N(s);
var Y = (s, b) => {
  for (let e in b)
    s.hasOwnProperty(e) ? s[e] = N(s[e], b[e]) : s[e] = b[e];
  return s;
};
var ce = (s, b$1) => {
  let { extend: e = null, slots: M = {}, variants: F = {}, compoundVariants: h$1 = [], compoundSlots: V = [], defaultVariants: U = {} } = s, m = { ...ie, ...b$1 }, S = e != null && e.base ? N(e.base, s == null ? void 0 : s.base) : s == null ? void 0 : s.base, g$1 = e != null && e.variants && !u(e.variants) ? p(F, e.variants) : F, A = e != null && e.defaultVariants && !u(e.defaultVariants) ? { ...e.defaultVariants, ...U } : U;
  !u(m.twMergeConfig) && !x(m.twMergeConfig, C) && (q = true, C = m.twMergeConfig);
  let O = u(e == null ? void 0 : e.slots), $ = u(M) ? {} : { base: N(s == null ? void 0 : s.base, O && (e == null ? void 0 : e.base)), ...M }, w = O ? $ : Y({ ...e == null ? void 0 : e.slots }, u($) ? { base: s == null ? void 0 : s.base } : $), v = (f$1) => {
    if (u(g$1) && u(M) && O)
      return j(S, f$1 == null ? void 0 : f$1.class, f$1 == null ? void 0 : f$1.className)(m);
    if (h$1 && !Array.isArray(h$1))
      throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof h$1}`);
    if (V && !Array.isArray(V))
      throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof V}`);
    let K = (t, n, a2 = [], i2) => {
      let r = a2;
      if (typeof n == "string")
        r = r.concat(g(n).split(" ").map((l2) => `${t}:${l2}`));
      else if (Array.isArray(n))
        r = r.concat(n.reduce((l2, c) => l2.concat(`${t}:${c}`), []));
      else if (typeof n == "object" && typeof i2 == "string") {
        for (let l2 in n)
          if (n.hasOwnProperty(l2) && l2 === i2) {
            let c = n[l2];
            if (c && typeof c == "string") {
              let o = g(c);
              r[i2] ? r[i2] = r[i2].concat(o.split(" ").map((u2) => `${t}:${u2}`)) : r[i2] = o.split(" ").map((u2) => `${t}:${u2}`);
            } else
              Array.isArray(c) && c.length > 0 && (r[i2] = c.reduce((o, u2) => o.concat(`${t}:${u2}`), []));
          }
      }
      return r;
    }, W = (t, n = g$1, a$1 = null, i2 = null) => {
      var I;
      let r = n[t];
      if (!r || u(r))
        return null;
      let l2 = (I = i2 == null ? void 0 : i2[t]) != null ? I : f$1 == null ? void 0 : f$1[t];
      if (l2 === null)
        return null;
      let c = l(l2), o = Array.isArray(m.responsiveVariants) && m.responsiveVariants.length > 0 || m.responsiveVariants === true, u2 = A == null ? void 0 : A[t], d = [];
      if (typeof c == "object" && o)
        for (let [T, J] of Object.entries(c)) {
          let ne = r[J];
          if (T === "initial") {
            u2 = J;
            continue;
          }
          Array.isArray(m.responsiveVariants) && !m.responsiveVariants.includes(T) || (d = K(T, ne, d, a$1));
        }
      let ae = c != null && typeof c != "object" ? c : l(u2), k = r[ae] || r.false;
      return typeof d == "object" && typeof a$1 == "string" && d[a$1] ? Y(d, k) : d.length > 0 ? (d.push(k), d) : k;
    }, P = () => g$1 ? Object.keys(g$1).map((t) => W(t, g$1)) : null, p2 = (t, n) => {
      if (!g$1 || typeof g$1 != "object")
        return null;
      let a2 = new Array();
      for (let i2 in g$1) {
        let r = W(i2, g$1, t, n), l2 = t === "base" && typeof r == "string" ? r : r && r[t];
        l2 && (a2[a2.length] = l2);
      }
      return a2;
    }, x2 = {};
    for (let t in f$1)
      f$1[t] !== void 0 && (x2[t] = f$1[t]);
    let z = (t, n) => {
      var i2;
      let a2 = typeof (f$1 == null ? void 0 : f$1[t]) == "object" ? { [t]: (i2 = f$1[t]) == null ? void 0 : i2.initial } : {};
      return { ...A, ...x2, ...a2, ...n };
    }, D = (t = [], n) => {
      let a2 = [];
      for (let { class: i2, className: r, ...l2 } of t) {
        let c = true;
        for (let [o, u2] of Object.entries(l2)) {
          let d = z(o, n);
          if (Array.isArray(u2)) {
            if (!u2.includes(d[o])) {
              c = false;
              break;
            }
          } else if (d[o] !== u2) {
            c = false;
            break;
          }
        }
        c && (i2 && a2.push(i2), r && a2.push(r));
      }
      return a2;
    }, H = (t) => {
      let n = D(h$1, t), a2 = D(e == null ? void 0 : e.compoundVariants, t);
      return a(a2, n);
    }, ee = (t) => {
      let n = H(t);
      if (!Array.isArray(n))
        return n;
      let a2 = {};
      for (let i2 of n)
        if (typeof i2 == "string" && (a2.base = j(a2.base, i2)(m)), typeof i2 == "object")
          for (let [r, l2] of Object.entries(i2))
            a2[r] = j(a2[r], l2)(m);
      return a2;
    }, te = (t) => {
      if (V.length < 1)
        return null;
      let n = {};
      for (let { slots: a2 = [], class: i2, className: r, ...l2 } of V) {
        if (!u(l2)) {
          let c = true;
          for (let o of Object.keys(l2)) {
            let u2 = z(o, t)[o];
            if (u2 === void 0 || (Array.isArray(l2[o]) ? !l2[o].includes(u2) : l2[o] !== u2)) {
              c = false;
              break;
            }
          }
          if (!c)
            continue;
        }
        for (let c of a2)
          n[c] = n[c] || [], n[c].push([i2, r]);
      }
      return n;
    };
    if (!u(M) || !O) {
      let t = {};
      if (typeof w == "object" && !u(w))
        for (let n of Object.keys(w))
          t[n] = (a2) => {
            var i2, r;
            return j(w[n], p2(n, a2), ((i2 = ee(a2)) != null ? i2 : [])[n], ((r = te(a2)) != null ? r : [])[n], a2 == null ? void 0 : a2.class, a2 == null ? void 0 : a2.className)(m);
          };
      return t;
    }
    return j(S, P(), H(), f$1 == null ? void 0 : f$1.class, f$1 == null ? void 0 : f$1.className)(m);
  }, _ = () => {
    if (!(!g$1 || typeof g$1 != "object"))
      return Object.keys(g$1);
  };
  return v.variantKeys = _(), v.extend = e, v.base = S, v.slots = w, v.variants = g$1, v.defaultVariants = A, v.compoundSlots = V, v.compoundVariants = h$1, v;
};
var oe = (s) => (b, e) => ce(b, e ? p(s, e) : s);
export {
  j as cn,
  N as cnBase,
  oe as createTV,
  ie as defaultConfig,
  ce as tv,
  Z as voidEmpty
};
//# sourceMappingURL=tailwind-variants.js.map
